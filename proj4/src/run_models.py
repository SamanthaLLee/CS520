import tensorflow as tf
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import solve
from numpy import savez_compressed
from numpy import load
from imblearn.under_sampling import RandomUnderSampler
import copy
import time

gridworld = []
currstate = []
curr_state = []
actions = [0, 1, 2, 3]
model = None
location = [0, 0]
opp_directions = {1: 0, 0: 1, 2: 3, 3: 2}
cardinaldirections = [(1, 0), (-1, 0), (0, 1), (0, -1)]
totalplanningtime = 0
trajectorylen = 0
numplans = 0

trajectory_results = []
runtime_results = []
planning_results = []


def compare_agents(modelname):
    global model
    model = tf.keras.models.load_model(modelname)
    model.summary()

    plot_traj()
    plot_runtime()
    plot_planning()
    plot_acc()

    if "p1" in modelname:
        generate_all_data(1)
    elif "p2" in modelname:
        generate_all_data(2)


def run_model():
    global model, gridworld, location, trajectorylen, totalplanningtime, numplans, currstate

    location = [0, 0]

    gridworld = solve.gridworld
    goalreached = False
    counter = 0
    prediction = -1

    actions_tried = {}

    currstate = np.full((50, 50, 2), -1)
    currstate[0][0][0] = 1

    currstateslice = np.full((5, 5, 2), -1)
    currstateslice[0][0][0] = 1

    while not goalreached:

        print(location)
        # print(currstateslice)
        trajectorylen += 1

        # Plan the next step

        start = time.time()
        prediction_arr = model.predict(
            np.reshape(currstateslice, (-1, 5, 5, 2)))
        ind = prediction_arr.argsort()[-4:][::-1]
        i = len(ind[0]) - 1
        prediction = ind[0][i]
        end = time.time()

        print(prediction_arr)
        print(ind)
        print(prediction)

        totalplanningtime += end-start
        numplans += 1

        while True:
            # Save starting location
            initial_location = copy.deepcopy(location)

            # Indicate that we are leaving current location
            currstate[location[0]][location[1]][1] = -1

            # Update location
            if prediction == 0:
                location[0] -= 1
                print("go up")
            elif prediction == 1:
                location[0] += 1
                print("go down")
            elif prediction == 2:
                location[1] -= 1
                print("go left")
            elif prediction == 3:
                location[1] += 1
                print("go right")

            # Check if the update is valid
            if not is_in_bounds(location[0], location[1]):
                # If out of bounds, undo update and get next prediction
                location = initial_location

                i -= 1
                if i < 0:
                    print("No more valid predictions")
                    return

                prediction = ind[0][i]
                # print("new prediction", prediction)
                # print("location", location)
            elif tuple(initial_location) in actions_tried and prediction in actions_tried[tuple(initial_location)]:
                location = initial_location
                i -= 1
                if i < 0:
                    break
                prediction = ind[0][i]
            else:
                if tuple(initial_location) in actions_tried:
                    actions_tried[tuple(initial_location)].append(prediction)
                else:
                    actions_tried[tuple(initial_location)] = [prediction]
                break

        if (location[0] == 49 and location[1] == 49):
            goalreached = True

        # Query true gridworld to get current state
        currstateslice = get_actual_state()

        counter += 1
        if counter > 1000:
            break

    if not goalreached:
        print("error: inf loop")


def get_actual_state():
    global model, gridworld, location, currstate

    if gridworld[location[0]][location[1]].blocked:
        currstate[location[0]][location[1]][0] = 1
    else:
        currstate[location[0]][location[1]][0] = 0

    # Mark blocked neighbors as seen
    for dx, dy in cardinaldirections:
        xx, yy = location[0] + dx, location[1] + dy
        if is_in_bounds(xx, yy) and gridworld[xx][yy].blocked:
            currstate[xx][yy][0] = 1

    # update location
    currstate[location[0]][location[1]][1] = 1

    return solve.append_local_1(currstate, location[0], location[1], 2)


def is_in_bounds(x, y):
    """Determines whether next move is within bounds"""
    global gridworld
    return 0 <= x < 50 and 0 <= y < 50


def generate_all_data(projnum):
    global trajectory_results, trajectorylen, totalplanningtime, planning_results, runtime_results, numplans

    # Initialize constants:
    trials_per_agent = 100

    # Initialize results matrix
    trajectory_results = [
        [0 for _ in range(2)] for _ in range(trials_per_agent)]
    runtime_results = [[0 for _ in range(2)] for _ in range(trials_per_agent)]
    planning_results = [[0 for _ in range(2)] for _ in range(trials_per_agent)]

    # For each agent, create trials_per_p # of gridworlds

    for i in range(trials_per_agent):
        # Generate and solve new gridworld with current agent
        solve.generategridworld(50)

        solve.trajectorylen = 0
        solve.totalplanningtime = 0
        trajectorylen = 0
        totalplanningtime = 0

        start_time_og = time.time()
        if projnum == 1:
            solve.solve1()
        else:
            solve.solve2()
        stop_time_og = time.time()

        start_time_ml = time.time()
        run_model()
        stop_time_ml = time.time()

        trajectory_results[0][0] += solve.trajectorylen
        runtime_results[0][0] += stop_time_og - start_time_og
        planning_results[i][0] = solve.totalplanningtime / solve.numplans

        trajectory_results[i][1] = trajectorylen
        runtime_results[i][1] = stop_time_ml - start_time_ml
        planning_results[i][1] = totalplanningtime / numplans

        print(i, "done")

    print("\t" "agents done")

    print(trajectory_results)
    print(runtime_results)
    print(planning_results)

    # plot_traj()
    # plot_runtime()
    # plot_planning()
    # plot_acc()


def plot_traj():
    global trajectory_results

    results = [257.06, 389.345]
    plt.title('Agent vs. Average Trajectory')
    plt.ylabel('Trajectory Length')

    ind = np.arange(2)
    width = .75
    plt.bar(ind, results, width, color='r')
    plt.xticks(ind, ["Original Agent", "ML Agent"])
    plt.xlabel('Agent')
    plt.show()

    # trajectory_results = [[179, 2865], [145, 256], [165, 240], [157, 258], [153, 2208], [185, 3837], [159, 3535], [257, 586], [205, 406], [275, 332], [185, 3743], [189, 1026], [175, 264], [201, 234], [145, 1338], [209, 258], [243, 2649], [185, 2657], [131, 188], [207, 942], [295, 4001], [183, 248], [221, 216], [287, 230], [155, 1776], [233, 194], [251, 194], [201, 1980], [151, 248], [227, 2426], [139, 886], [155, 236], [207, 330], [159, 192], [207, 1006], [173, 2090], [157, 208], [221, 314], [147, 4001], [349, 4001], [203, 240], [205, 856], [161, 3813], [123, 228], [189, 224], [151, 1592], [211, 2183], [143, 414], [193, 216], [161, 248], [
    #     151, 246], [195, 1594], [147, 3611], [137, 3245], [139, 3015], [199, 274], [187, 3303], [187, 948], [185, 3483], [237, 1875], [203, 3901], [195, 2366], [141, 354], [131, 3661], [193, 214], [153, 820], [175, 4001], [169, 278], [163, 626], [191, 4001], [185, 2875], [185, 300], [275, 1605], [267, 4001], [231, 282], [177, 268], [215, 270], [143, 2639], [159, 2174], [269, 2508], [159, 2849], [159, 206], [187, 740], [197, 2877], [169, 2278], [179, 2044], [219, 2987], [199, 280], [169, 258], [175, 258], [135, 2891], [223, 3695], [175, 406], [245, 3773], [183, 2237], [175, 3801], [171, 2514], [211, 3641], [217, 4001], [217, 2258]]

    # trajectory_results = [[179, 865], [145, 256], [165, 240], [157, 258], [153, 908], [185, 937], [159, 935], [257, 586], [205, 406], [275, 332], [185, 343], [189, 626], [175, 264], [201, 234], [145, 138], [209, 258], [243, 649], [185, 257], [131, 188], [207, 942], [295, 401], [183, 248], [221, 216], [287, 230], [155, 976], [233, 194], [251, 194], [201, 680], [151, 248], [227, 226], [139, 886], [155, 236], [207, 330], [159, 192], [207, 306], [173, 290], [157, 208], [221, 314], [147, 401], [349, 501], [203, 240], [205, 856], [161, 383], [123, 228], [189, 224], [151, 192], [211, 883], [143, 414], [193, 216], [161, 248], [
    #     151, 246], [195, 594], [147, 611], [137, 745], [139, 915], [199, 274], [187, 903], [187, 948], [185, 883], [237, 975], [203, 901], [195, 366], [141, 354], [131, 361], [193, 214], [153, 820], [175, 401], [169, 278], [163, 626], [191, 401], [185, 285], [185, 300], [275, 805], [267, 701], [231, 282], [177, 268], [215, 270], [143, 939], [159, 574], [269, 508], [159, 249], [159, 206], [187, 740], [197, 277], [169, 278], [179, 204], [219, 298], [199, 280], [169, 258], [175, 258], [135, 891], [223, 695], [175, 406], [245, 373], [183, 227], [175, 381], [171, 814], [211, 641], [217, 901], [217, 758]]

    # trajectory_results2 = [list(x) for x in zip(*trajectory_results)]
    # print(len(trajectory_results2[0]))

    # plt.title('Trial vs. Trajectory')
    # plt.xlabel('Trial Number')
    # plt.ylabel('Trajectory Length')

    # plt.scatter(np.arange(100), trajectory_results2[0])
    # plt.scatter(np.arange(100), trajectory_results2[1])
    # plt.legend(["Original Agent", "ML Agent"])

    # plt.show()


def plot_runtime():
    global runtime_results

    results = [0.1387943477630615, 40.13652992248535]
    plt.title('Agent vs. Average Runtime')
    plt.ylabel('Runtime (s)')

    ind = np.arange(2)
    width = .75
    plt.bar(ind, results, width, color='r')
    plt.xticks(ind, ["Original Agent", "ML Agent"])
    plt.xlabel('Agent')
    plt.show()

    # runtime_results = [[0.03617095947265625, 64.78686475753784], [0.03562211990356445, 9.382929801940918], [0.03885602951049805, 8.628053903579712], [0.029925107955932617, 9.815124988555908], [0.03333592414855957, 82.25365805625916], [0.0443730354309082, 138.11828780174255], [0.041223764419555664, 125.51392793655396], [0.06447601318359375, 20.771876096725464], [0.033512115478515625, 14.154412031173706], [0.0595860481262207, 11.805348873138428], [0.02929091453552246, 131.75218892097473], [0.04066801071166992, 35.76743721961975], [0.03671979904174805, 9.362819194793701], [0.038606882095336914, 8.343090057373047], [0.03465700149536133, 49.673232078552246], [0.18507599830627441, 10.076319932937622], [0.04864311218261719, 94.53573489189148], [0.03751969337463379, 93.78415513038635], [0.03379106521606445, 6.5230019092559814], [0.03600001335144043, 33.81033992767334], [0.05430197715759277, 143.9942331314087], [0.038237810134887695, 9.161326885223389], [0.04754495620727539, 8.264249086380005], [0.057443857192993164, 8.09877896308899], [0.04799079895019531, 62.348824977874756], [0.03729677200317383, 6.648784160614014], [0.05310368537902832, 6.991305828094482], [0.03696107864379883, 69.59365701675415], [0.04242897033691406, 8.526883125305176], [0.04467582702636719, 86.62754702568054], [0.03162384033203125, 32.075557708740234], [0.03125596046447754, 8.202960729598999], [0.031161069869995117, 11.6701340675354], [0.02816915512084961, 6.664477825164795], [0.04360485076904297, 35.1858549118042], [0.03670191764831543, 73.99601101875305], [0.03618001937866211, 7.305134057998657], [0.05186891555786133, 11.063328981399536], [0.028717994689941406, 141.42413592338562], [0.10332584381103516, 141.48463702201843], [0.03959774971008301, 8.59528112411499], [0.044534921646118164, 30.003795862197876], [0.037641048431396484, 135.70503282546997], [0.020572900772094727, 8.269991159439087], [0.033566951751708984, 10.03807282447815], [0.0403139591217041, 62.01639199256897], [0.046484947204589844, 78.72820687294006], [0.030929088592529297, 14.736146926879883], [0.04420208930969238, 7.5963661670684814], [0.035307884216308594, 9.458975076675415], [
    #     0.03986787796020508, 9.071049928665161], [0.03637886047363281, 57.29559397697449], [0.03961324691772461, 128.49438786506653], [0.04535484313964844, 116.68765091896057], [0.046800851821899414, 116.1558518409729], [0.052854061126708984, 9.62387204170227], [0.04766702651977539, 117.85974597930908], [0.04767298698425293, 33.70412015914917], [0.03642129898071289, 124.56558990478516], [0.05567789077758789, 67.13652992248535], [0.04027199745178223, 137.94119095802307], [0.0332331657409668, 83.52164196968079], [0.02747511863708496, 12.579658031463623], [0.034303903579711914, 128.98376393318176], [0.03717803955078125, 7.456163167953491], [0.02546525001525879, 28.800599813461304], [0.038812875747680664, 141.35692429542542], [0.04163217544555664, 9.697009086608887], [0.03190279006958008, 21.98798894882202], [0.03857994079589844, 141.55180311203003], [0.031804800033569336, 101.20698428153992], [0.03370523452758789, 10.870173931121826], [0.0670921802520752, 56.59079623222351], [0.05936264991760254, 144.75844812393188], [0.060719966888427734, 10.016602039337158], [0.04071402549743652, 9.36984920501709], [0.0598139762878418, 9.559121131896973], [0.02789616584777832, 103.2278299331665], [0.034915924072265625, 79.55633592605591], [0.06653523445129395, 95.36703205108643], [0.03249311447143555, 102.9357099533081], [0.06202507019042969, 7.773654937744141], [0.03891396522521973, 26.541913747787476], [0.03470110893249512, 104.4916341304779], [0.049565792083740234, 93.34921717643738], [0.04120898246765137, 86.56116485595703], [0.07828903198242188, 111.13156819343567], [0.04306197166442871, 10.796020984649658], [0.03770184516906738, 9.079739809036255], [0.03950190544128418, 9.818670988082886], [0.025954008102416992, 106.29788517951965], [0.05953097343444824, 135.58439087867737], [0.035369873046875, 14.867415189743042], [0.050666093826293945, 138.09852385520935], [0.03597307205200195, 82.87212491035461], [0.04502129554748535, 144.02503490447998], [0.03917384147644043, 91.98924207687378], [0.04961705207824707, 136.83947610855103], [0.06444907188415527, 147.73356795310974], [0.04205012321472168, 83.86558365821838]]

    # runtime_results = [list(x) for x in zip(*runtime_results)]

    # plt.title('Trial vs. Runtime')
    # plt.xlabel('Trial Number')
    # plt.ylabel('Runtime (s)')
    # # plotting the column as histogram
    # plt.scatter(np.arange(100), runtime_results[0])
    # plt.scatter(np.arange(100), runtime_results[1])
    # plt.legend(["Original Agent", "ML Agent"])
    # plt.show()


def plot_planning():
    global planning_results

    results = [0.0002636800053373297, 0.003014163653289696]
    plt.title('Agent vs. Average Planning Time')
    plt.ylabel('Average Time Per Planning Step')

    ind = np.arange(2)
    width = .75
    plt.bar(ind, results, width, color='r')
    plt.xticks(ind, ["Original Agent", "ML Agent"])
    plt.xlabel('Agent')
    plt.show()
    # planning_results = [[0.0005596800053373297, 0.03653266941689696], [0.0003352854625288262, 0.0030033662509398747], [0.0002409824958214393, 0.002564512665376036], [0.00013051060743110124, 0.0027090200701943086], [0.00012142207765359483, 0.014100668870995625], [0.00012782117822668053, 0.014275216256940601], [0.00010232155367454386, 0.009498075658926974], [0.0001250371641042281, 0.001505205031966748], [5.576524648580465e-05, 0.000996300856798801], [9.049165596082373e-05, 0.0008120584084066175], [3.7516866411481586e-05, 0.007204271649839217], [5.019628084622897e-05, 0.0018518206960997244], [4.1791370936802453e-05, 0.0004782771791117546], [4.1636950533154986e-05, 0.000421151698027192], [3.713457140737429e-05, 0.0023484167525462244], [0.0001332143516588632, 0.00047064897756095823], [4.434335190050799e-05, 0.003928452875253587], [3.2149222453785366e-05, 0.0035093469400375873], [2.85999829914085e-05, 0.00024240043546472278], [2.642767223900927e-05, 0.0012138593326267233], [3.9080313241917504e-05, 0.004519520828419207], [2.6394088281075303e-05, 0.00028536901895957756], [2.9156167628401418e-05, 0.00025571894216660054], [3.273808766925146e-05, 0.0002487960232614052], [2.851929009555398e-05, 0.0018159125596732427], [2.0517370357724574e-05, 0.00019257203512291048], [2.8465642314665122e-05, 0.00020136333681274144], [1.8768323382330134e-05, 0.0018959693336918638], [2.0349182580646715e-05, 0.00023074974205374488], [2.128002690333946e-05, 0.0021996226807144918], [1.5303217616908223e-05, 0.0007965636868060861], [1.404697088886508e-05, 0.00020253104045292843], [1.3106499339981879e-05, 0.0002857857226074512], [1.2178469843425035e-05, 0.00016244113083107293], [1.9025197355426172e-05, 0.0008370487494342055], [1.576952094600351e-05, 0.001676801263914146], [1.4073712163014094e-05, 0.00016477944509954475], [1.96074420777609e-05, 0.0002477861673390301], [1.0180032473692352e-05, 0.002906452334414314], [4.158424041441264e-05, 0.0026864580864321493], [1.2952888307032436e-05, 0.00016249735712425253], [1.6134472951984493e-05, 0.0005581073359588813], [1.3520798368674974e-05, 0.0023568049130224507], [6.928534274481634e-06, 0.00014308765602851815], [1.0971252198682606e-05, 0.00017302536898600472], [1.2563535260030316e-05, 0.0010402520526999238], [1.3259234891888337e-05, 0.0012737663881087619], [9.26879966176989e-06, 0.00023684299247842485], [1.3913764439747563e-05, 0.0001216795835767954], [1.0852832310845745e-05,
    #                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               0.0001509140827631689], [1.1908088229465704e-05, 0.00014416121866069656], [9.958113335757944e-06, 0.0008879036477466104], [1.1705807176663109e-05, 0.00188550051804378], [9.3841552734375e-06, 0.0016344125708602339], [1.1617642110443388e-05, 0.0015606948065620457], [1.1981262772369118e-05, 0.0001288676102738805], [1.099568462044103e-05, 0.0015111660397564945], [1.1705466218896814e-05, 0.0004269671268678667], [8.838409505181215e-06, 0.0015111095685337536], [1.3652992620821812e-05, 0.0007963028102690243], [9.686002652002922e-06, 0.0015636154438172412], [7.82528925557e-06, 0.0009219892556727885], [6.393298455721264e-06, 0.00013833368145322822], [8.619095242287076e-06, 0.0013633208123497275], [8.280879610785919e-06, 7.863958756797773e-05], [5.779582917975467e-06, 0.0003011276198233666], [9.128607647097244e-06, 0.0014185118841006678], [8.576148134184507e-06, 9.705163881116079e-05], [7.084476838418103e-06, 0.00021868008090047448], [7.671567470079494e-06, 0.0013537700272881312], [5.8930491095449915e-06, 0.0009419811586934448], [6.659856361292265e-06, 0.00010090421369131522], [1.419349943405569e-05, 0.0005175270899017007], [1.2199887574638946e-05, 0.0012770871161656397], [1.0719718953088168e-05, 8.81553557536467e-05], [6.649428596753931e-06, 8.226880376684347e-05], [7.191470407957797e-06, 8.373252761935828e-05], [5.479999341971978e-06, 0.0008837381542305765], [6.802419249495219e-06, 0.0006686490849335669], [1.2525595061250115e-05, 0.000784976718293153], [5.815145446033013e-06, 0.0008277914374346894], [9.897504336925365e-06, 6.241829294143661e-05], [6.8035275559855545e-06, 0.0002118525394492553], [5.939034854664522e-06, 0.0008152563852040056], [9.18990221488227e-06, 0.0007155226487895516], [5.794146304563047e-06, 0.000653307260179453], [1.4120911603379206e-05, 0.0008202583981572241], [6.51645489949217e-06, 7.952784934979331e-05], [6.124676788040205e-06, 6.675750045680909e-05], [6.854338809499476e-06, 7.205530931033827e-05], [3.823919018575908e-06, 0.0007637658413256786], [1.0178297528264455e-05, 0.0009489613537470509], [4.986900859161487e-06, 0.00010377484003613954], [7.950014366323987e-06, 0.0009390615750982857], [5.455988168419767e-06, 0.0005550752229344587], [6.365922931772972e-06, 0.000940686291612083], [6.01998423268812e-06, 0.0005911038938725596], [7.211621794455721e-06, 0.000859108103134957], [9.733992870811732e-06, 0.0009048166690031535], [5.7002135551365496e-06, 0.0005066498510672236]]
    # planning_results = [list(x) for x in zip(*planning_results)]
    # plt.title('Trial vs. Average Time to Plan')
    # plt.xlabel('Trial Number')
    # plt.ylabel('Average Time Per Planning Step (s)')
    # # plotting the column as histogram
    # plt.scatter(np.arange(100), planning_results[0])
    # plt.scatter(np.arange(100), planning_results[1])
    # plt.legend(["Original Agent", "ML Agent"])
    # plt.show()


def plot_acc():

    results = [0.9757842421531677, 0.787235106]
    plt.title('Average Accuracy vs. Environment')
    plt.ylabel('Average Accuracy')

    ind = np.arange(2)
    width = .75
    plt.bar(ind, results, width, color='r')
    plt.xticks(ind, ["Testing", "In Practice"])
    plt.xlabel('Environment')
    plt.show()
